{"ast":null,"code":"var _jsxFileName = \"/Users/uthaya/ourjourneys/src/components/ProjectList/ProjectList.js\";\nimport React, { Component, useState } from \"react\";\nimport { TweenLite, gsap } from \"gsap\";\nimport { Draggable } from \"gsap/Draggable\";\nimport Isotope from 'isotope-layout';\nimport image1 from \"./image-1.jpg\";\nimport image2 from \"./image-2.jpg\";\nimport image3 from \"./image-3.jpg\";\nimport image4 from \"./image-4.jpg\";\nimport \"./ProjectList.scss\";\ngsap.registerPlugin(Draggable);\nconst containerId = \"imageContainer\";\nconst containerSelector = \"#\" + containerId;\nconst rowClass = \"row\";\nconst rowSelector = \".\" + rowClass;\nconst imageClass = \"sliderImage\";\nconst imageSelector = \".\" + imageClass;\nconst imgURLArray = [{\n  src: image1,\n  class: \"toto\"\n}, {\n  src: image2,\n  class: \"tata\"\n}, {\n  src: image3,\n  class: \"tata\"\n}, {\n  src: image4,\n  class: \"toto\"\n}];\nconst imgURLArrayLength = imgURLArray ? imgURLArray.length : -1;\nconst rowNum = 4;\nconst imgNum = 6;\nconst useInertia = true;\nconst useCenterGrid = true;\nlet rows, imgMidIndex, rowMidIndex;\nconst rowArray = [];\nconst imgRep = [];\nlet boxWidth, boxHeight, gutter, horizSpacing, vertSpacing, horizOffset, vertOffset, winMidX, winMidY, lastCenteredElem;\n\nclass projectList extends Component {\n  constructor(props) {\n    super(props);\n\n    this.onFilterChange = newFilter => {\n      if (newFilter === '*') {\n        this.setStyles();\n      } else {\n        this.setStyles(newFilter);\n      }\n    };\n\n    this.centerGrid = () => {\n      let bcr = lastCenteredElem.getBoundingClientRect();\n      let midX = bcr.x + bcr.width / 2;\n      let midY = bcr.y + bcr.height / 2;\n      let x = winMidX - midX;\n      let y = winMidY - midY;\n      gsap.to(containerSelector, {\n        ease: \"sine.inOut\",\n        duration: 0.7,\n        x: \"+=\" + x,\n        y: \"+=\" + y\n      });\n    };\n\n    this.updateCenterElem = () => {\n      let elems = document.elementsFromPoint(winMidX, winMidY);\n      elems.forEach(elem => {\n        if (elem.matches(imageSelector) && !lastCenteredElem.isSameNode(elem)) {\n          lastCenteredElem = elem;\n          this.checkPositions(lastCenteredElem);\n        }\n      });\n    };\n\n    this.mouseMove = e => {\n      TweenLite.to(this.myRef.current, 0.5, {\n        css: {\n          left: e.pageX,\n          top: e.pageY\n        },\n        delay: 0.03\n      });\n    };\n\n    this.handleMouseEnter = () => {\n      TweenLite.to(this.myRef.current, 0, {\n        css: {\n          opacity: \"1\"\n        }\n      });\n    };\n\n    this.handleMouseLeave = () => {\n      TweenLite.to(this.myRef.current, 0, {\n        css: {\n          opacity: \"0\"\n        }\n      });\n    };\n\n    this.onHover = e => {\n      if (e.target.className === \"lib__item\") {\n        TweenLite.to(this.myRef.current, 0, {\n          css: {\n            \"background-image\": \"url(\" + image1 + \")\"\n          }\n        });\n      }\n\n      if (e.target.className === \"project p-2\") {\n        TweenLite.to(this.myRef.current, 0, {\n          css: {\n            \"background-image\": \"url(\" + image2 + \")\"\n          }\n        });\n      }\n\n      if (e.target.className === \"project p-3\") {\n        TweenLite.to(this.myRef.current, 0, {\n          css: {\n            \"background-image\": \"url(\" + image3 + \")\"\n          }\n        });\n      }\n\n      if (e.target.className === \"project p-4\") {\n        TweenLite.to(this.myRef.current, 0, {\n          css: {\n            \"background-image\": \"url(\" + image4 + \")\"\n          }\n        });\n      }\n    };\n\n    this.myRef = React.createRef();\n    this.onFilterChange = this.onFilterChange.bind(this);\n  }\n\n  componentDidMount() {\n    this.init();\n  }\n\n  init() {\n    gsap.set(containerSelector, {\n      willChange: \"transform\"\n    });\n    this.createImageGrid();\n    this.createMask();\n    lastCenteredElem = document.querySelectorAll(imageSelector)[(rowMidIndex - 1) * imgNum + imgMidIndex];\n    this.createDraggable();\n    this.setStyles();\n    this.resize();\n    window.addEventListener(\"resize\", this.resize);\n  }\n\n  moveArrayIndex(array, oldIndex, newIndex) {\n    if (newIndex >= array.length) {\n      newIndex = array.length - 1;\n    }\n\n    array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);\n    return array;\n  }\n\n  checkPositions(elem) {\n    // Find the location in our array of the element\n    let rowIndex = -1,\n        imgIndex = -1;\n    imgRep.forEach((row, i) => {\n      row.forEach((img, j) => {\n        if (elem.isSameNode(img)) {\n          rowIndex = i;\n          imgIndex = j;\n        }\n      });\n    }); // Element not found, return\n\n    if (rowIndex === -1) return; // Reposition elements as necessary so that our element is in the center\n    // Reposition the rows as necessary\n\n    if (rowIndex < rowMidIndex) {\n      for (let i = rowIndex; i < rowMidIndex; i++) {\n        // Update the row's actual position\n        let rowY = gsap.getProperty(rowArray[0], \"y\");\n\n        if (rowArray.length % 2 === 1) {\n          // Odd number of rows means we have to handle offset\n          let row = rowArray[rowArray.length - 1];\n\n          if (row.dataset.offset === \"true\") {\n            gsap.set(row, {\n              y: rowY - gutter - boxHeight,\n              x: \"+=\" + boxWidth / 2\n            });\n            row.dataset.offset = \"false\";\n          } else {\n            gsap.set(row, {\n              y: rowY - gutter - boxHeight,\n              x: \"-=\" + boxWidth / 2\n            });\n            row.dataset.offset = \"true\";\n          }\n        } else {\n          // Equal number of rows; don't have to handle offset\n          gsap.set(rowArray[rowArray.length - 1], {\n            y: rowY - gutter - boxHeight\n          });\n        } // Update our representations\n\n\n        this.moveArrayIndex(imgRep, imgRep.length - 1, 0);\n        this.moveArrayIndex(rowArray, rowArray.length - 1, 0);\n      }\n    } else if (rowIndex > rowMidIndex) {\n      for (let i = rowMidIndex; i < rowIndex; i++) {\n        // Update the row's actual position\n        let rowY = gsap.getProperty(rowArray[rowArray.length - 1], \"y\");\n\n        if (rowArray.length % 2 === 1) {\n          // Odd number of rows means we have to handle offset\n          let row = rowArray[0];\n\n          if (row.dataset.offset === \"true\") {\n            gsap.set(row, {\n              y: rowY + gutter + boxHeight,\n              x: \"-=\" + boxWidth / 2\n            });\n            row.dataset.offset = \"false\";\n          } else {\n            gsap.set(row, {\n              y: rowY + gutter + boxHeight,\n              x: \"+=\" + boxWidth / 2\n            });\n            row.dataset.offset = \"true\";\n          }\n        } else {\n          // Equal number of rows; don't have to handle offset\n          gsap.set(rowArray[0], {\n            y: rowY + gutter + boxHeight\n          });\n        } // Update our representations\n\n\n        this.moveArrayIndex(imgRep, 0, imgRep.length - 1);\n        this.moveArrayIndex(rowArray, 0, rowArray.length - 1);\n      }\n    } // Reposition the images as necessary\n\n\n    if (imgIndex < imgMidIndex) {\n      for (let rowNum = 0; rowNum < rows.length; rowNum++) {\n        // Do it for every row\n        let row = imgRep[rowNum];\n\n        for (let i = imgIndex; i < imgMidIndex; i++) {\n          // Update the images's actual position\n          let imgX = gsap.getProperty(row[0], \"x\");\n          gsap.set(row[row.length - 1], {\n            x: imgX - gutter - boxWidth\n          }); // Update our representation\n\n          this.moveArrayIndex(row, row.length - 1, 0);\n        }\n      }\n    } else if (imgIndex > imgMidIndex) {\n      for (let rowNum = 0; rowNum < rows.length; rowNum++) {\n        // Do it for every row\n        let row = imgRep[rowNum];\n\n        for (let i = imgMidIndex; i < imgIndex; i++) {\n          // Update the images's actual position\n          let imgX = gsap.getProperty(row[imgNum - 1], \"x\");\n          gsap.set(row[0], {\n            x: imgX + gutter + boxWidth\n          }); // Update our representation\n\n          this.moveArrayIndex(row, 0, row.length - 1);\n        }\n      }\n    }\n  }\n\n  getCenterCoords(endX, endY) {\n    return {\n      x: winMidX - endX,\n      y: winMidY - endY\n    };\n  }\n\n  createImageGrid() {\n    for (let y = 0; y < rowNum; y++) {\n      let row = document.createElement(\"div\");\n      row.className = rowClass;\n\n      for (let x = 0; x < imgNum; x++) {\n        let image = document.createElement(\"div\");\n        let link = document.createElement(\"a\");\n        let legend = document.createElement(\"div\");\n        link.className = \"filter-item styles__font-size-xs styles__font-family-sans-serif styles__double-border Thumb__wrapper Thumb__size-small Thumb__layout-horizontal\";\n        image.className = imageClass;\n        row.appendChild(link);\n        link.appendChild(image);\n        legend.className = \"Thumb__title\";\n        legend.innerHTML = \"tototo\";\n        image.appendChild(legend);\n      }\n\n      document.querySelector(containerSelector).appendChild(row); // Add the images to our representation\n\n      imgRep.push(gsap.utils.toArray(row.querySelectorAll(imageSelector)));\n    }\n\n    rows = document.querySelectorAll(rowSelector);\n    imgMidIndex = Math.floor(imgNum / 2);\n    rowMidIndex = Math.floor(rowNum / 2);\n  }\n\n  createMask() {\n    let mask = document.createElement(\"div\");\n    mask.className = \"mask\";\n    document.body.appendChild(mask);\n    gsap.set(mask, {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: \"100vw\",\n      height: \"100vh\",\n      zIndex: 9999 // backgroundColor: \"green\",\n      // opacity: \"0.2\",\n\n    });\n  }\n\n  resize() {\n    winMidX = window.innerWidth / 2;\n    winMidY = window.innerHeight / 2;\n    boxWidth = window.innerWidth * 0.35;\n    boxHeight = window.innerHeight * 0.35;\n    gutter = window.innerWidth * 0.09;\n    horizSpacing = boxWidth + gutter * 1.5;\n    vertSpacing = boxHeight + gutter;\n    horizOffset = -(imgMidIndex * horizSpacing + boxWidth / 2) + winMidX;\n    vertOffset = -(rowMidIndex * vertSpacing + boxHeight / 2) + winMidY; // Reset our container and rows\n\n    gsap.set(containerSelector, {\n      x: 0,\n      y: 0\n    });\n    rows.forEach(function (row, i) {\n      gsap.set(row, {\n        attr: {\n          \"data-offset\": function () {\n            if (i % 2 === 0) return false;else return true;\n          }\n        },\n        x: function () {\n          if (i % 2 === 0) return horizOffset;else return horizOffset - boxWidth / 2;\n        },\n        y: function () {\n          return i * vertSpacing + vertOffset;\n        }\n      });\n      gsap.set(row.querySelectorAll(imageSelector), {\n        width: boxWidth * 0.5,\n        height: boxHeight,\n        x: function (index) {\n          return index * horizSpacing;\n        }\n      }); // Update our representation of the rows\n\n      rowArray[i] = row;\n    });\n  }\n\n  setStyles(param) {\n    gsap.set(\"body\", {\n      margin: 0,\n      overflow: \"hidden\"\n    });\n\n    if (param) {\n      const newImages = imgURLArray.filter(element => element.class === param);\n      const newImagesArrayLength = newImages ? newImages.length : -1;\n    }\n\n    const randImgSize = Math.floor(Math.max(window.innerWidth, window.innerHeight) / 3);\n    gsap.set(imageSelector, {\n      backgroundImage: function (index) {\n        if (param) {\n          return `url(` + newImages[index % newImagesArrayLength].src + `)`;\n        } else {\n          return `url(` + imgURLArray[index % imgURLArrayLength].src + `)`;\n        }\n      },\n      position: \"absolute\",\n      backgroundSize: \"cover\",\n      backgroundPosition: \"center\",\n      border: \"4px solid\",\n      top: 0,\n      left: 0\n    });\n    gsap.set(rowSelector, {\n      position: \"absolute\"\n    });\n  }\n\n  createDraggable() {\n    let options = {\n      trigger: \".mask\",\n      dragResistance: 0.4,\n      resistance: 400,\n      onDrag: this.updateCenterElem\n    };\n\n    if (useInertia) {\n      options.inertia = true;\n      options.onThrowUpdate = this.updateCenterElem;\n\n      if (useCenterGrid) {\n        options.onThrowComplete = this.centerGrid;\n      }\n    } else if (useCenterGrid) {\n      // No inertia\n      options.onDragEnd = this.centerGrid;\n    }\n\n    return Draggable.create(containerSelector, options);\n  }\n  /*moveArrayIndex(array, oldIndex, newIndex) {\n      if (newIndex >= array.length) {\n          newIndex = array.length - 1;\n      }\n      array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);\n      return array;\n  }\n    checkPositions(elem) {\n  // Find the location in our array of the element\n    let rowIndex = -1,\n        imgIndex = -1;\n    imgRep.forEach((row, i) => {\n      row.forEach((img, j) => {\n        if(elem.isSameNode(img)) {\n          rowIndex = i;\n          imgIndex = j;\n        }\n      });\n    });\n  \n  // Element not found, return\n    if(rowIndex === -1)\n      return;\n    \n    // Reposition elements as necessary so that our element is in the center\n    // Reposition the rows as necessary\n    if(rowIndex < rowMidIndex) {\n      for(let i = rowIndex; i < rowMidIndex; i++) {\n        // Update the row's actual position\n        let rowY = gsap.getProperty(rowArray[0], \"y\");\n        \n        if(rowArray.length % 2 === 1) { // Odd number of rows means we have to handle offset\n          let row = rowArray[rowArray.length - 1];\n          if(row.dataset.offset === \"true\") {\n            gsap.set(row, {y: rowY - gutter - boxHeight, x: \"+=\" + boxWidth / 2});\n            row.dataset.offset = \"false\";\n          } else {\n            gsap.set(row, {y: rowY - gutter - boxHeight, x: \"-=\" + boxWidth / 2});\n            row.dataset.offset = \"true\";\n          }\n        } else { // Equal number of rows; don't have to handle offset\n          gsap.set(rowArray[rowArray.length - 1], {y: rowY - gutter - boxHeight});\n        }\n        \n        // Update our representations\n        this.moveArrayIndex(imgRep, imgRep.length - 1, 0);\n        this.moveArrayIndex(rowArray, rowArray.length - 1, 0);\n      }\n    } else if(rowIndex > rowMidIndex) {\n      for(let i = rowMidIndex; i < rowIndex; i++) {\n        // Update the row's actual position\n        let rowY = gsap.getProperty(rowArray[rowArray.length - 1], \"y\");\n        \n        if(rowArray.length % 2 === 1) { // Odd number of rows means we have to handle offset\n          let row = rowArray[0];\n          if(row.dataset.offset === \"true\") {\n            gsap.set(row, {y: rowY + gutter + boxHeight, x: \"-=\" + boxWidth / 2});\n            row.dataset.offset = \"false\";\n          } else {\n            gsap.set(row, {y: rowY + gutter + boxHeight, x: \"+=\" + boxWidth / 2});\n            row.dataset.offset = \"true\";\n          }\n        } else { // Equal number of rows; don't have to handle offset\n          gsap.set(rowArray[0], {y: rowY + gutter + boxHeight});\n        }\n        \n        // Update our representations\n        this.moveArrayIndex(imgRep, 0, imgRep.length - 1);\n        this.moveArrayIndex(rowArray, 0, rowArray.length - 1);\n      }\n    }\n  \n  \n    // Reposition the images as necessary\n    if(imgIndex < imgMidIndex) {\n      for(let rowNum = 0; rowNum < rows.length; rowNum++) { // Do it for every row\n        let row = imgRep[rowNum];\n        \n        for(let i = imgIndex; i < imgMidIndex; i++) {\n          // Update the images's actual position\n          let imgX = gsap.getProperty(row[0], \"x\");\n           gsap.set(row[row.length - 1], {x: imgX - gutter - boxWidth});\n           // Update our representation\n          this.moveArrayIndex(row, row.length - 1, 0);\n        }\n      }\n    } else if(imgIndex > imgMidIndex) {\n      for(let rowNum = 0; rowNum < rows.length; rowNum++) { // Do it for every row\n        let row = imgRep[rowNum];\n        \n        for(let i = imgMidIndex; i < imgIndex; i++) {\n          // Update the images's actual position\n          let imgX = gsap.getProperty(row[imgNum - 1], \"x\");\n           gsap.set(row[0], {x: imgX + gutter + boxWidth});\n           // Update our representation\n          this.moveArrayIndex(row, 0, row.length - 1);\n        }\n      }\n    }\n  }\n    centerGrid() {\n    let bcr = lastCenteredElem.getBoundingClientRect();\n    let midX = bcr.x + bcr.width / 2;\n    let midY = bcr.y + bcr.height / 2;\n    \n    let x = winMidX - midX;\n    let y = winMidY - midY;\n    \n    gsap.to(containerSelector, {\n      ease: \"sine.inOut\",\n      duration: 0.7,\n      x: \"+=\" + x,\n      y: \"+=\" + y\n    });\n  }\n   updateCenterElem() {\n    let elems = document.elementsFromPoint(winMidX, winMidY);\n    elems.forEach(elem => {\n      if(elem.matches(imageSelector) && !lastCenteredElem.isSameNode(elem)) {\n        lastCenteredElem = elem; \n        \n        this.checkPositions(lastCenteredElem);\n      }\n    });\n  }\n   createMask() {\n    let mask = document.createElement(\"div\");\n    mask.className = \"mask\";\n    document.body.appendChild(mask);\n    \n    gsap.set(mask, {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: \"100vw\",\n      height: \"100vh\",\n      zIndex: 9999,\n    });\n  }*/\n\n  /*resize() {\n    winMidX = innerWidth / 2;\n    winMidY = innerHeight / 2;\n    boxWidth = innerWidth * 0.35;\n    boxHeight = innerHeight * 0.35;\n    gutter = innerWidth * 0.05;\n    horizSpacing = boxWidth + gutter;\n    vertSpacing = boxHeight + gutter;\n    horizOffset = -(imgMidIndex * horizSpacing + boxWidth / 2) + winMidX;\n    vertOffset = -(rowMidIndex * vertSpacing + boxHeight / 2) + winMidY;\n    \n    // Reset our container and rows\n    gsap.set(containerSelector, {x: 0, y: 0, rotate: 30});\n    let imgNum = document.querySelectorAll(imageSelector);\n    for (var i = 0; i < imgNum.length; i++) {\n        gsap.set(imgNum[i], {\n          x: function() {\n              return 0;\n          },\n          y: function() {\n            return 0;\n          },\n        });\n    }\n     var callback = function (entries, observer) {\n      entries.forEach(function(entry) {\n        if (entry.isIntersecting) {\n          // play the individual target.timeline\n          entry.target.timeline.play();\n        } else {\n          //entry.target.timeline.pause(0);\n        }\n      });\n    };\n     var options = {\n      threshold: 0.6, // target 'section' should be 60% visible\n      rootMargin: '0px 0px -40% 0px'\n      //rootMargin isn't active in a normal CodePen.\n      //Change View: use DebugMode\n    };\n     var observer = new IntersectionObserver(callback, options);\n    var targets = document.querySelectorAll(imageSelector);\n     // a loop: create the individual target timelines\n    targets.forEach(function(target) {\n      var ww = window.innerWidth + 300;\n      var action = gsap.timeline({paused:false})\n      .to(target, {\n        duration: 10, \n        x:ww, \n        ease: \"sine.inOut\", \n        repeat: -1\n      });\n      \n      target.timeline = action;\n    });\n     Array.prototype.forEach.call(targets, (el) => {observer.observe(el);});  \n    \n  }\n   createDraggable() {\n    let options = {\n      trigger: \".mask\",\n      dragResistance: 0.4,\n      resistance: 400,\n      rotate: 45,\n    }\n    \n    if(useInertia) {\n      options.inertia = true;\n    }\n        \n    return Draggable.create(imageSelector, options);\n  }*/\n\n\n  changeBackground(e) {\n    e.target.style.background = 'red';\n  }\n\n  render() {\n    const dragInfo = {\n      position: 'absolute',\n      bottom: '20%'\n    };\n    return React.createElement(React.Fragment, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 651\n      },\n      __self: this\n    }, React.createElement(\"ul\", {\n      id: \"portfolio-flters\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 652\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      \"data-filter\": \"*\",\n      onClick: () => {\n        this.onFilterChange(\"*\");\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 653\n      },\n      __self: this\n    }, \"All\"), React.createElement(\"li\", {\n      \"data-filter\": \"filter-one\",\n      onClick: () => {\n        this.onFilterChange(\"toto\");\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 654\n      },\n      __self: this\n    }, \"One\"), React.createElement(\"li\", {\n      \"data-filter\": \"filter-two\",\n      onClick: () => {\n        this.onFilterChange(\"tata\");\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 655\n      },\n      __self: this\n    }, \"Two\")), React.createElement(\"div\", {\n      className: \"Container__wrapper Container__center\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 657\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 658\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"Intro__wrapper\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 659\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      className: \"Heading__wrapper styles__font-size-xl styles__font-family-serif-bold Intro__title\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 660\n      },\n      __self: this\n    }, \"Nos voyages\\uD83C\\uDFDD\"), React.createElement(\"div\", {\n      className: \"Heading__wrapper styles__font-size-sm Intro__desc\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 661\n      },\n      __self: this\n    }, \"Retrouvez ici toutes les villes que nous avons visit\\xE9.\"))), React.createElement(\"div\", {\n      className: \"Container__wrapper Container__absolute Container__center\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 664\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"Container__wrapper Container__absolute Container__center\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 665\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"Heading__wrapper styles__font-size-xs\",\n      style: dragInfo,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 666\n      },\n      __self: this\n    }, \"DRAG POUR EXPLORER\"), React.createElement(\"div\", {\n      id: \"imageContainer\",\n      className: \"filter-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 667\n      },\n      __self: this\n    }))));\n  }\n\n}\n\nexport default projectList;","map":{"version":3,"sources":["/Users/uthaya/ourjourneys/src/components/ProjectList/ProjectList.js"],"names":["React","Component","useState","TweenLite","gsap","Draggable","Isotope","image1","image2","image3","image4","registerPlugin","containerId","containerSelector","rowClass","rowSelector","imageClass","imageSelector","imgURLArray","src","class","imgURLArrayLength","length","rowNum","imgNum","useInertia","useCenterGrid","rows","imgMidIndex","rowMidIndex","rowArray","imgRep","boxWidth","boxHeight","gutter","horizSpacing","vertSpacing","horizOffset","vertOffset","winMidX","winMidY","lastCenteredElem","projectList","constructor","props","onFilterChange","newFilter","setStyles","centerGrid","bcr","getBoundingClientRect","midX","x","width","midY","y","height","to","ease","duration","updateCenterElem","elems","document","elementsFromPoint","forEach","elem","matches","isSameNode","checkPositions","mouseMove","e","myRef","current","css","left","pageX","top","pageY","delay","handleMouseEnter","opacity","handleMouseLeave","onHover","target","className","createRef","bind","componentDidMount","init","set","willChange","createImageGrid","createMask","querySelectorAll","createDraggable","resize","window","addEventListener","moveArrayIndex","array","oldIndex","newIndex","splice","rowIndex","imgIndex","row","i","img","j","rowY","getProperty","dataset","offset","imgX","getCenterCoords","endX","endY","createElement","image","link","legend","appendChild","innerHTML","querySelector","push","utils","toArray","Math","floor","mask","body","position","zIndex","innerWidth","innerHeight","attr","index","param","margin","overflow","newImages","filter","element","newImagesArrayLength","randImgSize","max","backgroundImage","backgroundSize","backgroundPosition","border","options","trigger","dragResistance","resistance","onDrag","inertia","onThrowUpdate","onThrowComplete","onDragEnd","create","changeBackground","style","background","render","dragInfo","bottom"],"mappings":"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","sourcesContent":["import React, { Component, useState } from \"react\";\nimport { TweenLite, gsap } from \"gsap\";\nimport { Draggable } from \"gsap/Draggable\";\nimport Isotope from 'isotope-layout';\nimport image1 from \"./image-1.jpg\";\nimport image2 from \"./image-2.jpg\";\nimport image3 from \"./image-3.jpg\";\nimport image4 from \"./image-4.jpg\";\n\nimport \"./ProjectList.scss\";\n\ngsap.registerPlugin(Draggable);\nconst containerId = \"imageContainer\";\nconst containerSelector = \"#\" + containerId;\nconst rowClass = \"row\"\nconst rowSelector = \".\" + rowClass;\nconst imageClass = \"sliderImage\";\nconst imageSelector = \".\" + imageClass;\nconst imgURLArray = [{src: image1, class: \"toto\"}, {src: image2, class: \"tata\"}, {src: image3, class: \"tata\"}, {src: image4, class: \"toto\"}];\nconst imgURLArrayLength = imgURLArray ? imgURLArray.length : -1;\nconst rowNum = 4;\nconst imgNum = 6;\n\nconst useInertia = true;\nconst useCenterGrid = true;\n\nlet rows,\n    imgMidIndex,\n    rowMidIndex;\nconst rowArray = [];\nconst imgRep = [];\n\nlet boxWidth,\n    boxHeight,\n    gutter,\n    horizSpacing,\n    vertSpacing,\n    horizOffset,\n    vertOffset,\n    winMidX,\n    winMidY,\n    lastCenteredElem;\n\nclass projectList extends Component {\n  constructor(props) {\n    super(props);\n\n    this.myRef = React.createRef();\n    this.onFilterChange = this.onFilterChange.bind(this);\n  }\n\n  componentDidMount() {\n    this.init();\n  };\n\n  init() {\n    gsap.set(containerSelector, {willChange: \"transform\"});\n  \n    this.createImageGrid();\n    this.createMask();\n    lastCenteredElem = document.querySelectorAll(imageSelector)[(rowMidIndex - 1) * imgNum + imgMidIndex];\n    \n    this.createDraggable();\n    \n    this.setStyles();\n    \n    this.resize();\n    window.addEventListener(\"resize\", this.resize);\n  }\n\n  onFilterChange = (newFilter) => {\n    if(newFilter === '*') {\n      this.setStyles();\n    } else {\n      this.setStyles(newFilter);\n    }\n  }\n\n  moveArrayIndex(array, oldIndex, newIndex) {\n    if (newIndex >= array.length) {\n        newIndex = array.length - 1;\n    }\n    array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);\n    return array;\n  }\n\n\ncheckPositions(elem) {\n  // Find the location in our array of the element\n  let rowIndex = -1,\n      imgIndex = -1;\n  imgRep.forEach((row, i) => {\n    row.forEach((img, j) => {\n      if(elem.isSameNode(img)) {\n        rowIndex = i;\n        imgIndex = j;\n      }\n    });\n  });\n  \n  // Element not found, return\n  if(rowIndex === -1)\n    return;\n  \n  // Reposition elements as necessary so that our element is in the center\n  // Reposition the rows as necessary\n  if(rowIndex < rowMidIndex) {\n    for(let i = rowIndex; i < rowMidIndex; i++) {\n      // Update the row's actual position\n      let rowY = gsap.getProperty(rowArray[0], \"y\");\n      \n      if(rowArray.length % 2 === 1) { // Odd number of rows means we have to handle offset\n        let row = rowArray[rowArray.length - 1];\n        if(row.dataset.offset === \"true\") {\n          gsap.set(row, {y: rowY - gutter - boxHeight, x: \"+=\" + boxWidth / 2});\n          row.dataset.offset = \"false\";\n        } else {\n          gsap.set(row, {y: rowY - gutter - boxHeight, x: \"-=\" + boxWidth / 2});\n          row.dataset.offset = \"true\";\n        }\n      } else { // Equal number of rows; don't have to handle offset\n        gsap.set(rowArray[rowArray.length - 1], {y: rowY - gutter - boxHeight});\n      }\n      \n      // Update our representations\n      this.moveArrayIndex(imgRep, imgRep.length - 1, 0);\n      this.moveArrayIndex(rowArray, rowArray.length - 1, 0);\n    }\n  } else if(rowIndex > rowMidIndex) {\n    for(let i = rowMidIndex; i < rowIndex; i++) {\n      // Update the row's actual position\n      let rowY = gsap.getProperty(rowArray[rowArray.length - 1], \"y\");\n      \n      if(rowArray.length % 2 === 1) { // Odd number of rows means we have to handle offset\n        let row = rowArray[0];\n        if(row.dataset.offset === \"true\") {\n          gsap.set(row, {y: rowY + gutter + boxHeight, x: \"-=\" + boxWidth / 2});\n          row.dataset.offset = \"false\";\n        } else {\n          gsap.set(row, {y: rowY + gutter + boxHeight, x: \"+=\" + boxWidth / 2});\n          row.dataset.offset = \"true\";\n        }\n      } else { // Equal number of rows; don't have to handle offset\n        gsap.set(rowArray[0], {y: rowY + gutter + boxHeight});\n      }\n      \n      // Update our representations\n      this.moveArrayIndex(imgRep, 0, imgRep.length - 1);\n      this.moveArrayIndex(rowArray, 0, rowArray.length - 1);\n    }\n  }\n  \n  \n  // Reposition the images as necessary\n  if(imgIndex < imgMidIndex) {\n    for(let rowNum = 0; rowNum < rows.length; rowNum++) { // Do it for every row\n      let row = imgRep[rowNum];\n      \n      for(let i = imgIndex; i < imgMidIndex; i++) {\n        // Update the images's actual position\n        let imgX = gsap.getProperty(row[0], \"x\");\n\n        gsap.set(row[row.length - 1], {x: imgX - gutter - boxWidth});\n\n        // Update our representation\n        this.moveArrayIndex(row, row.length - 1, 0);\n      }\n    }\n  } else if(imgIndex > imgMidIndex) {\n    for(let rowNum = 0; rowNum < rows.length; rowNum++) { // Do it for every row\n      let row = imgRep[rowNum];\n      \n      for(let i = imgMidIndex; i < imgIndex; i++) {\n        // Update the images's actual position\n        let imgX = gsap.getProperty(row[imgNum - 1], \"x\");\n\n        gsap.set(row[0], {x: imgX + gutter + boxWidth});\n\n        // Update our representation\n        this.moveArrayIndex(row, 0, row.length - 1);\n      }\n    }\n  }\n}\n\n\ncenterGrid = () => {\n  let bcr = lastCenteredElem.getBoundingClientRect();\n  let midX = bcr.x + bcr.width / 2;\n  let midY = bcr.y + bcr.height / 2;\n  \n  let x = winMidX - midX;\n  let y = winMidY - midY;\n  \n  gsap.to(containerSelector, {\n    ease: \"sine.inOut\",\n    duration: 0.7,\n    x: \"+=\" + x,\n    y: \"+=\" + y\n  });\n}\n\ngetCenterCoords(endX, endY) {\n  return {x: winMidX - endX, y: winMidY - endY}\n}\n\nupdateCenterElem = () => {\n  let elems = document.elementsFromPoint(winMidX, winMidY);\n  elems.forEach(elem => {\n    if(elem.matches(imageSelector) && !lastCenteredElem.isSameNode(elem)) {\n      lastCenteredElem = elem; \n      \n      this.checkPositions(lastCenteredElem);\n    }\n  });\n}\n\ncreateImageGrid() {\n  for(let y = 0; y < rowNum; y++) {\n    let row = document.createElement(\"div\");\n    row.className = rowClass;\n      for(let x = 0; x < imgNum; x++) {\n        let image = document.createElement(\"div\");\n        let link = document.createElement(\"a\");\n        let legend = document.createElement(\"div\");\n        link.className = \"filter-item styles__font-size-xs styles__font-family-sans-serif styles__double-border Thumb__wrapper Thumb__size-small Thumb__layout-horizontal\";\n        image.className = imageClass;\n        row.appendChild(link);\n        link.appendChild(image);\n        legend.className = \"Thumb__title\";\n        legend.innerHTML = \"tototo\";\n        image.appendChild(legend);\n      }\n    document.querySelector(containerSelector).appendChild(row);\n    \n    // Add the images to our representation\n    imgRep.push(gsap.utils.toArray(row.querySelectorAll(imageSelector)));\n  }\n  \n  rows = document.querySelectorAll(rowSelector);\n  imgMidIndex = Math.floor(imgNum / 2);\n  rowMidIndex = Math.floor(rowNum / 2);\n}\n\ncreateMask() {\n  let mask = document.createElement(\"div\");\n  mask.className = \"mask\";\n  document.body.appendChild(mask);\n  \n  gsap.set(mask, {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    width: \"100vw\",\n    height: \"100vh\",\n    zIndex: 9999,\n    // backgroundColor: \"green\",\n    // opacity: \"0.2\",\n  });\n}\n\nresize() {\n  winMidX = window.innerWidth / 2;\n  winMidY = window.innerHeight / 2;\n  boxWidth = window.innerWidth * 0.35;\n  boxHeight = window.innerHeight * 0.35;\n  gutter = window.innerWidth * 0.09;\n  horizSpacing = boxWidth + gutter * 1.5;\n  vertSpacing = boxHeight + gutter;\n  horizOffset = -(imgMidIndex * horizSpacing + boxWidth / 2) + winMidX;\n  vertOffset = -(rowMidIndex * vertSpacing + boxHeight / 2) + winMidY;\n  \n  // Reset our container and rows\n  gsap.set(containerSelector, {x: 0, y: 0});\n  \n  rows.forEach(function(row, i) {\n    gsap.set(row, {\n      attr: { \n        \"data-offset\": function() {\n          if(i % 2 === 0) return false;\n          else return true;\n        }\n      },\n      x: function() {\n        if(i % 2 === 0)\n          return horizOffset;\n        else\n          return horizOffset - boxWidth / 2;\n      },\n      y: function() {\n        return i * vertSpacing + vertOffset;\n      },\n    });\n\n    gsap.set(row.querySelectorAll(imageSelector), {\n      width: boxWidth * 0.5,\n      height: boxHeight,\n      x: function(index) {\n        return index * horizSpacing;\n      }\n    });\n    \n    // Update our representation of the rows\n    rowArray[i] = row;\n  });\n}\n\nsetStyles(param) {\n  gsap.set(\"body\", {\n    margin: 0,\n    overflow: \"hidden\"\n  });\n\n  if (param) {\n    const newImages = imgURLArray.filter(element => element.class === param);\n    const newImagesArrayLength = newImages ? newImages.length : -1;\n  }\n\n  const randImgSize = Math.floor( Math.max(window.innerWidth, window.innerHeight) / 3);\n  gsap.set(imageSelector, {\n    backgroundImage: function(index) {\n      if (param) {\n        return `url(` + newImages[index % newImagesArrayLength].src + `)`;\n      } else {\n        return `url(` + imgURLArray[index % imgURLArrayLength].src + `)`;\n      }\n    },\n    position: \"absolute\",\n    backgroundSize: \"cover\",\n    backgroundPosition: \"center\",\n    border: \"4px solid\",\n    top: 0,\n    left: 0\n  });\n  \n  gsap.set(rowSelector, {\n    position: \"absolute\"\n  });\n}\n\ncreateDraggable() {\n  let options = {\n    trigger: \".mask\",\n    dragResistance: 0.4,\n    resistance: 400,\n    onDrag: this.updateCenterElem,\n  }\n  \n  if(useInertia) {\n    options.inertia = true;\n    options.onThrowUpdate = this.updateCenterElem;\n    \n    if(useCenterGrid) {\n      options.onThrowComplete = this.centerGrid;\n    }\n  } else if(useCenterGrid) { // No inertia\n    options.onDragEnd = this.centerGrid;\n  }\n      \n  return Draggable.create(containerSelector, options);\n}\n\n  /*moveArrayIndex(array, oldIndex, newIndex) {\n      if (newIndex >= array.length) {\n          newIndex = array.length - 1;\n      }\n      array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);\n      return array;\n  }\n\n\n  checkPositions(elem) {\n  // Find the location in our array of the element\n    let rowIndex = -1,\n        imgIndex = -1;\n    imgRep.forEach((row, i) => {\n      row.forEach((img, j) => {\n        if(elem.isSameNode(img)) {\n          rowIndex = i;\n          imgIndex = j;\n        }\n      });\n    });\n  \n  // Element not found, return\n    if(rowIndex === -1)\n      return;\n    \n    // Reposition elements as necessary so that our element is in the center\n    // Reposition the rows as necessary\n    if(rowIndex < rowMidIndex) {\n      for(let i = rowIndex; i < rowMidIndex; i++) {\n        // Update the row's actual position\n        let rowY = gsap.getProperty(rowArray[0], \"y\");\n        \n        if(rowArray.length % 2 === 1) { // Odd number of rows means we have to handle offset\n          let row = rowArray[rowArray.length - 1];\n          if(row.dataset.offset === \"true\") {\n            gsap.set(row, {y: rowY - gutter - boxHeight, x: \"+=\" + boxWidth / 2});\n            row.dataset.offset = \"false\";\n          } else {\n            gsap.set(row, {y: rowY - gutter - boxHeight, x: \"-=\" + boxWidth / 2});\n            row.dataset.offset = \"true\";\n          }\n        } else { // Equal number of rows; don't have to handle offset\n          gsap.set(rowArray[rowArray.length - 1], {y: rowY - gutter - boxHeight});\n        }\n        \n        // Update our representations\n        this.moveArrayIndex(imgRep, imgRep.length - 1, 0);\n        this.moveArrayIndex(rowArray, rowArray.length - 1, 0);\n      }\n    } else if(rowIndex > rowMidIndex) {\n      for(let i = rowMidIndex; i < rowIndex; i++) {\n        // Update the row's actual position\n        let rowY = gsap.getProperty(rowArray[rowArray.length - 1], \"y\");\n        \n        if(rowArray.length % 2 === 1) { // Odd number of rows means we have to handle offset\n          let row = rowArray[0];\n          if(row.dataset.offset === \"true\") {\n            gsap.set(row, {y: rowY + gutter + boxHeight, x: \"-=\" + boxWidth / 2});\n            row.dataset.offset = \"false\";\n          } else {\n            gsap.set(row, {y: rowY + gutter + boxHeight, x: \"+=\" + boxWidth / 2});\n            row.dataset.offset = \"true\";\n          }\n        } else { // Equal number of rows; don't have to handle offset\n          gsap.set(rowArray[0], {y: rowY + gutter + boxHeight});\n        }\n        \n        // Update our representations\n        this.moveArrayIndex(imgRep, 0, imgRep.length - 1);\n        this.moveArrayIndex(rowArray, 0, rowArray.length - 1);\n      }\n    }\n  \n  \n    // Reposition the images as necessary\n    if(imgIndex < imgMidIndex) {\n      for(let rowNum = 0; rowNum < rows.length; rowNum++) { // Do it for every row\n        let row = imgRep[rowNum];\n        \n        for(let i = imgIndex; i < imgMidIndex; i++) {\n          // Update the images's actual position\n          let imgX = gsap.getProperty(row[0], \"x\");\n\n          gsap.set(row[row.length - 1], {x: imgX - gutter - boxWidth});\n\n          // Update our representation\n          this.moveArrayIndex(row, row.length - 1, 0);\n        }\n      }\n    } else if(imgIndex > imgMidIndex) {\n      for(let rowNum = 0; rowNum < rows.length; rowNum++) { // Do it for every row\n        let row = imgRep[rowNum];\n        \n        for(let i = imgMidIndex; i < imgIndex; i++) {\n          // Update the images's actual position\n          let imgX = gsap.getProperty(row[imgNum - 1], \"x\");\n\n          gsap.set(row[0], {x: imgX + gutter + boxWidth});\n\n          // Update our representation\n          this.moveArrayIndex(row, 0, row.length - 1);\n        }\n      }\n    }\n  }\n\n\n  centerGrid() {\n    let bcr = lastCenteredElem.getBoundingClientRect();\n    let midX = bcr.x + bcr.width / 2;\n    let midY = bcr.y + bcr.height / 2;\n    \n    let x = winMidX - midX;\n    let y = winMidY - midY;\n    \n    gsap.to(containerSelector, {\n      ease: \"sine.inOut\",\n      duration: 0.7,\n      x: \"+=\" + x,\n      y: \"+=\" + y\n    });\n  }\n\n  updateCenterElem() {\n    let elems = document.elementsFromPoint(winMidX, winMidY);\n    elems.forEach(elem => {\n      if(elem.matches(imageSelector) && !lastCenteredElem.isSameNode(elem)) {\n        lastCenteredElem = elem; \n        \n        this.checkPositions(lastCenteredElem);\n      }\n    });\n  }\n\n  createMask() {\n    let mask = document.createElement(\"div\");\n    mask.className = \"mask\";\n    document.body.appendChild(mask);\n    \n    gsap.set(mask, {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: \"100vw\",\n      height: \"100vh\",\n      zIndex: 9999,\n    });\n  }*/\n\n  /*resize() {\n    winMidX = innerWidth / 2;\n    winMidY = innerHeight / 2;\n    boxWidth = innerWidth * 0.35;\n    boxHeight = innerHeight * 0.35;\n    gutter = innerWidth * 0.05;\n    horizSpacing = boxWidth + gutter;\n    vertSpacing = boxHeight + gutter;\n    horizOffset = -(imgMidIndex * horizSpacing + boxWidth / 2) + winMidX;\n    vertOffset = -(rowMidIndex * vertSpacing + boxHeight / 2) + winMidY;\n    \n    // Reset our container and rows\n    gsap.set(containerSelector, {x: 0, y: 0, rotate: 30});\n    let imgNum = document.querySelectorAll(imageSelector);\n    for (var i = 0; i < imgNum.length; i++) {\n        gsap.set(imgNum[i], {\n          x: function() {\n              return 0;\n          },\n          y: function() {\n            return 0;\n          },\n        });\n    }\n\n    var callback = function (entries, observer) {\n      entries.forEach(function(entry) {\n        if (entry.isIntersecting) {\n          // play the individual target.timeline\n          entry.target.timeline.play();\n        } else {\n          //entry.target.timeline.pause(0);\n        }\n      });\n    };\n\n    var options = {\n      threshold: 0.6, // target 'section' should be 60% visible\n      rootMargin: '0px 0px -40% 0px'\n      //rootMargin isn't active in a normal CodePen.\n      //Change View: use DebugMode\n    };\n\n    var observer = new IntersectionObserver(callback, options);\n    var targets = document.querySelectorAll(imageSelector);\n\n    // a loop: create the individual target timelines\n    targets.forEach(function(target) {\n      var ww = window.innerWidth + 300;\n      var action = gsap.timeline({paused:false})\n      .to(target, {\n        duration: 10, \n        x:ww, \n        ease: \"sine.inOut\", \n        repeat: -1\n      });\n      \n      target.timeline = action;\n    });\n\n    Array.prototype.forEach.call(targets, (el) => {observer.observe(el);});  \n    \n  }\n\n  createDraggable() {\n    let options = {\n      trigger: \".mask\",\n      dragResistance: 0.4,\n      resistance: 400,\n      rotate: 45,\n    }\n    \n    if(useInertia) {\n      options.inertia = true;\n    }\n        \n    return Draggable.create(imageSelector, options);\n  }*/\n\n  mouseMove = e => {\n    TweenLite.to(this.myRef.current, 0.5, {\n      css: {\n        left: e.pageX,\n        top: e.pageY\n      },\n      delay: 0.03\n    });\n  };\n\n  changeBackground(e) {\n    e.target.style.background = 'red';\n  }\n\n  handleMouseEnter = () => {\n    TweenLite.to(this.myRef.current, 0, {\n      css: {\n        opacity: \"1\"\n      }\n    });\n  };\n\n  handleMouseLeave = () => {\n    TweenLite.to(this.myRef.current, 0, {\n      css: {\n        opacity: \"0\"\n      }\n    });\n  };\n\n  onHover = e => {\n    if (e.target.className === \"lib__item\") {\n      TweenLite.to(this.myRef.current, 0, {\n        css: { \"background-image\": \"url(\" + image1 + \")\" }\n      });\n    }\n    if (e.target.className === \"project p-2\") {\n      TweenLite.to(this.myRef.current, 0, {\n        css: { \"background-image\": \"url(\" + image2 + \")\" }\n      });\n    }\n    if (e.target.className === \"project p-3\") {\n      TweenLite.to(this.myRef.current, 0, {\n        css: { \"background-image\": \"url(\" + image3 + \")\" }\n      });\n    }\n    if (e.target.className === \"project p-4\") {\n      TweenLite.to(this.myRef.current, 0, {\n        css: { \"background-image\": \"url(\" + image4 + \")\" }\n      });\n    }\n  };\n\n  render() {\n    const dragInfo = {\n      position: 'absolute', \n      bottom: '20%',\n    };\n    return (\n      <React.Fragment>\n        <ul id=\"portfolio-flters\">\n          <li data-filter=\"*\" onClick={() => {this.onFilterChange(\"*\")}}>All</li>\n          <li data-filter=\"filter-one\" onClick={() => {this.onFilterChange(\"toto\")}}>One</li>\n          <li data-filter=\"filter-two\" onClick={() => {this.onFilterChange(\"tata\")}}>Two</li>\n        </ul>\n        <div className=\"Container__wrapper Container__center\">\n          <div>\n            <div className=\"Intro__wrapper\">\n              <h1 className=\"Heading__wrapper styles__font-size-xl styles__font-family-serif-bold Intro__title\">Nos voyages</h1>\n              <div className=\"Heading__wrapper styles__font-size-sm Intro__desc\">Retrouvez ici toutes les villes que nous avons visit.</div>\n            </div>\n          </div>\n          <div className=\"Container__wrapper Container__absolute Container__center\"></div>\n          <div className=\"Container__wrapper Container__absolute Container__center\">\n              <div className=\"Heading__wrapper styles__font-size-xs\" style={dragInfo}>DRAG POUR EXPLORER</div>\n              <div id=\"imageContainer\" className=\"filter-container\"></div>\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default projectList;\n"]},"metadata":{},"sourceType":"module"}