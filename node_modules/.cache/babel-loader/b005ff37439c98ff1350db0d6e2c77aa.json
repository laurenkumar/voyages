{"ast":null,"code":"import { ShaderMaterial, Color, Face3, BackSide, Mesh } from 'three';\nvar fragmentShader = \"\\nuniform vec3 color;\\nuniform float coefficient;\\nuniform float power;\\nvarying vec3 vVertexNormal;\\nvarying vec3 vVertexWorldPosition;\\nvoid main() {\\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\\n  vec3 viewCameraToVertex\\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\\n  viewCameraToVertex = normalize(viewCameraToVertex);\\n  float intensity\\t= pow(\\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\\n    power\\n  );\\n  gl_FragColor = vec4(color, intensity);\\n}\";\nvar vertexShader = \"\\nvarying vec3 vVertexWorldPosition;\\nvarying vec3 vVertexNormal;\\nvoid main() {\\n  vVertexNormal\\t= normalize(normalMatrix * normal);\\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\\n  gl_Position\\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\"; // Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html\n\nfunction createGlowMaterial(coefficient, color, power) {\n  return new ShaderMaterial({\n    depthWrite: false,\n    fragmentShader: fragmentShader,\n    transparent: true,\n    uniforms: {\n      coefficient: {\n        type: 'f',\n        value: coefficient\n      },\n      color: {\n        type: 'c',\n        value: new Color(color)\n      },\n      power: {\n        type: 'f',\n        value: power\n      }\n    },\n    vertexShader: vertexShader\n  });\n}\n\nfunction createGlowGeometry(geometry, size) {\n  // gather vertexNormals from geometry.faces\n  var glowGeometry = geometry.clone();\n  var vertexNormals = new Array(glowGeometry.vertices.length);\n  glowGeometry.faces.forEach(function (face) {\n    if (face instanceof Face3) {\n      vertexNormals[face.a] = face.vertexNormals[0];\n      vertexNormals[face.b] = face.vertexNormals[1];\n      vertexNormals[face.c] = face.vertexNormals[2];\n    } else {\n      console.error('Face needs to be an instance of THREE.Face3.');\n    }\n  }); // modify the vertices according to vertexNormal\n\n  glowGeometry.vertices.forEach(function (vertex, i) {\n    var _a = vertexNormals[i],\n        x = _a.x,\n        y = _a.y,\n        z = _a.z;\n    vertex.x += x * size;\n    vertex.y += y * size;\n    vertex.z += z * size;\n  });\n  return glowGeometry;\n}\n\nvar defaultOptions = {\n  backside: true,\n  coefficient: 0.5,\n  color: 'gold',\n  size: 2,\n  power: 1\n};\n\nfunction createGlowMesh(geometry, options) {\n  if (options === void 0) {\n    options = defaultOptions;\n  }\n\n  var backside = options.backside,\n      coefficient = options.coefficient,\n      color = options.color,\n      size = options.size,\n      power = options.power;\n  var glowGeometry = createGlowGeometry(geometry, size);\n  var glowMaterial = createGlowMaterial(coefficient, color, power);\n\n  if (backside) {\n    glowMaterial.side = BackSide;\n  }\n\n  return new Mesh(glowGeometry, glowMaterial);\n}\n\nexport { createGlowGeometry, createGlowMaterial, createGlowMesh, defaultOptions };","map":{"version":3,"sources":["/Users/uthaya/ourjourneys/node_modules/three-glow-mesh/dist/index.module.js"],"names":["ShaderMaterial","Color","Face3","BackSide","Mesh","fragmentShader","vertexShader","createGlowMaterial","coefficient","color","power","depthWrite","transparent","uniforms","type","value","createGlowGeometry","geometry","size","glowGeometry","clone","vertexNormals","Array","vertices","length","faces","forEach","face","a","b","c","console","error","vertex","i","_a","x","y","z","defaultOptions","backside","createGlowMesh","options","glowMaterial","side"],"mappings":"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","sourcesContent":["import { ShaderMaterial, Color, Face3, BackSide, Mesh } from 'three';\n\nvar fragmentShader = \"\\nuniform vec3 color;\\nuniform float coefficient;\\nuniform float power;\\nvarying vec3 vVertexNormal;\\nvarying vec3 vVertexWorldPosition;\\nvoid main() {\\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\\n  vec3 viewCameraToVertex\\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\\n  viewCameraToVertex = normalize(viewCameraToVertex);\\n  float intensity\\t= pow(\\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\\n    power\\n  );\\n  gl_FragColor = vec4(color, intensity);\\n}\";\r\nvar vertexShader = \"\\nvarying vec3 vVertexWorldPosition;\\nvarying vec3 vVertexNormal;\\nvoid main() {\\n  vVertexNormal\\t= normalize(normalMatrix * normal);\\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\\n  gl_Position\\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\";\r\n// Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html\r\nfunction createGlowMaterial(coefficient, color, power) {\r\n    return new ShaderMaterial({\r\n        depthWrite: false,\r\n        fragmentShader: fragmentShader,\r\n        transparent: true,\r\n        uniforms: {\r\n            coefficient: {\r\n                type: 'f',\r\n                value: coefficient,\r\n            },\r\n            color: {\r\n                type: 'c',\r\n                value: new Color(color),\r\n            },\r\n            power: {\r\n                type: 'f',\r\n                value: power,\r\n            },\r\n        },\r\n        vertexShader: vertexShader,\r\n    });\r\n}\r\nfunction createGlowGeometry(geometry, size) {\r\n    // gather vertexNormals from geometry.faces\r\n    var glowGeometry = geometry.clone();\r\n    var vertexNormals = new Array(glowGeometry.vertices.length);\r\n    glowGeometry.faces.forEach(function (face) {\r\n        if (face instanceof Face3) {\r\n            vertexNormals[face.a] = face.vertexNormals[0];\r\n            vertexNormals[face.b] = face.vertexNormals[1];\r\n            vertexNormals[face.c] = face.vertexNormals[2];\r\n        }\r\n        else {\r\n            console.error('Face needs to be an instance of THREE.Face3.');\r\n        }\r\n    });\r\n    // modify the vertices according to vertexNormal\r\n    glowGeometry.vertices.forEach(function (vertex, i) {\r\n        var _a = vertexNormals[i], x = _a.x, y = _a.y, z = _a.z;\r\n        vertex.x += x * size;\r\n        vertex.y += y * size;\r\n        vertex.z += z * size;\r\n    });\r\n    return glowGeometry;\r\n}\r\nvar defaultOptions = {\r\n    backside: true,\r\n    coefficient: 0.5,\r\n    color: 'gold',\r\n    size: 2,\r\n    power: 1,\r\n};\r\nfunction createGlowMesh(geometry, options) {\r\n    if (options === void 0) { options = defaultOptions; }\r\n    var backside = options.backside, coefficient = options.coefficient, color = options.color, size = options.size, power = options.power;\r\n    var glowGeometry = createGlowGeometry(geometry, size);\r\n    var glowMaterial = createGlowMaterial(coefficient, color, power);\r\n    if (backside) {\r\n        glowMaterial.side = BackSide;\r\n    }\r\n    return new Mesh(glowGeometry, glowMaterial);\r\n}\n\nexport { createGlowGeometry, createGlowMaterial, createGlowMesh, defaultOptions };\n"]},"metadata":{},"sourceType":"module"}